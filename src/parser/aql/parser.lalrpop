use std::*;
use std::collections::VecDeque;
use super::ast;
use std::rc::Rc;

grammar;

pub Query : ast::Disjunction = {
    Disjunction => <>,
}

Disjunction : ast::Disjunction  = {
    <head:Conjunction> <tail:("|" Conjunction)*> => {
        let mut result = ast::Disjunction::new();
        result.push_front(head);
        for t in tail.into_iter() {
            result.push_front(t.1);
        }
        return result;
    },
}

Conjunction : ast::Conjunction = {
    <head:Factor> <tail:("&" Factor)*> => {
        let mut r = ast::Conjunction::new();
        r.push_front(head);
        for t in tail.into_iter() {
            r.push_front(t.1);
        }
        return r;
    },
}

Factor : ast::Factor = {
    Statement => ast::Factor::Statement(<>),
    "(" <d:Disjunction> ")" => ast::Factor::Disjunction(d),
}

Statement : VecDeque<ast::Statement> = {
    NodeSearch => VecDeque::from(vec![<>]),
    <lhs:Operand> <op:BinaryOpSpec> <rhs:Operand> <tail:(BinaryOpSpec Operand)*> => {
        let mut result : VecDeque<ast::Statement> = VecDeque::new();
        result.push_front(ast::Statement::BinaryOp(lhs.clone(), op, rhs.clone()));
        
        let mut last_operand = rhs.clone();
        for t in tail.into_iter() {
            result.push_front(ast::Statement::BinaryOp(last_operand.clone(), t.0, t.1.clone()));
            last_operand = t.1;
        }

        return result;
    },
}

Operand : ast::Operand = {
    NodeRef => ast::Operand::NodeRef(<>),
    NodeSearch => ast::Operand::Statement(Rc::from(<>)),
}

NodeSearch : ast::Statement = {
    TextSearch => ast::Statement::TokenSearch(<>),
    <name:QName> "=" <text:TextSearch> => ast::Statement::AnnoSearch(name, Some(text)),
    QName =>  ast::Statement::AnnoSearch(<>, None),
}


NodeRef : ast::NodeRef = {
    <v:r##"#[0-9]+"##> => ast::NodeRef::ID(v[1..].parse::<u32>().unwrap()),
    <v:r##"#[a-zA-Z][a-zA-Z0-9]*"##> => ast::NodeRef::Name(v[1..].to_string()),
}

BinaryOpSpec : ast::BinaryOpSpec = {
    ">" => ast::BinaryOpSpec::Dominance,
    "->" => ast::BinaryOpSpec::Pointing,
    "." => ast::BinaryOpSpec::Precedence,
    "_o_" => ast::BinaryOpSpec::Overlap,
    "_=_" => ast::BinaryOpSpec::IdenticalCoverage,
}

TextSearch: ast::TextSearch = {
    <v:r#""[^"]*""#> => ast::TextSearch(String::from(&v[1..v.len()-1]), ast::StringMatchType::Exact),
    // see https://stackoverflow.com/questions/37032620/regex-for-matching-a-string-literal-in-java 
    // for a example how to match escaped quotation characters
    <v:r#"/[^"\\]*(\\.[^"\\]*)*/"#> => ast::TextSearch(String::from(&v[1..v.len()-1]), ast::StringMatchType::Regex),
};

QName: ast::QName = {
    <ns:r"[a-zA-Z][a-zA-Z0-9]*"> ":" <name:r"[a-zA-Z][a-zA-Z0-9]*"> => ast::QName(Some(String::from(ns)), String::from(name)),
    <name:r"[a-zA-Z][a-zA-Z0-9]*"> => ast::QName(None, String::from(name)),
    
};


