use std::*;
use super::ast;
use std::rc::Rc;

use exec::nodesearch::NodeSearchSpec;
use aql::operators::{
    OverlapSpec, 
    IdenticalCoverageSpec,
    PrecedenceSpec,
    DominanceSpec,
    PointingSpec,
};

grammar;

match {
    "tok" => TOK,
} else {
    r"[a-zA-Z][a-zA-Z0-9]*" => ID,
    r##"#[0-9]+"## => NODE_REF,
    r##"#[a-zA-Z][a-zA-Z0-9]*"## => NAMED_NODE_REF,
    _
}

pub Disjunction : ast::Disjunction  = {
    <head:Conjunction> <tail:("|" Conjunction)*> => {
        let mut result = ast::Disjunction::new();
        for t in tail.into_iter() {
            result.push_front(t.1);
        }
        result.push_front(head);
        return result;
    },
}

Conjunction : ast::Conjunction = {
    <head:Factor> <tail:("&" Factor)*> => {
        let mut r = ast::Conjunction::new();
        for t in tail.into_iter() {
            for f in t.1.into_iter() {
                r.push_front(f);
            }
        }
        for f in head.into_iter() {
            r.push_front(f);
        }
        return r;
    },
}

Factor : Vec<ast::Factor> = {
    Literal => {
        let mut result = Vec::new();
        for l in <>.into_iter() {
            result.push(ast::Factor::Literal(l));
        }
        result
    },
    "(" <d:Disjunction> ")" => vec![ast::Factor::Disjunction(d)],
}

Literal : Vec<ast::Literal> = {
    <start: @L> <spec:NodeSearch> <end: @R> => {
        let pos = Some(ast::Pos{start, end});
        vec![ast::Literal::NodeSearch{pos, spec}]
    },
    <start: @L> <lhs:Operand> <op:BinaryOpSpec> <rhs:Operand> <tail:(BinaryOpSpec Operand)*> <end: @R> => {
        let mut result : Vec<ast::Literal> = Vec::new();
        // TODO: can we get the position for each individual binary operator?
        let pos = ast::Pos {
            start, end
        };
        result.push(ast::Literal::BinaryOp{lhs: lhs.clone(), op, rhs: rhs.clone(), pos: Some(pos.clone())});
        
        let mut last_operand = rhs.clone();
        for t in tail.into_iter() {
            result.push(ast::Literal::BinaryOp{
                lhs: last_operand.clone(), 
                op: t.0, 
                rhs: t.1.clone(), 
                pos: Some(pos.clone())
            });
            last_operand = t.1;
        }

        return result;
    },
}

Operand : ast::Operand = {
    NodeRef =>  ast::Operand::NodeRef(<>),
    NodeSearch => ast::Operand::Literal(Rc::from(<>)),
}

NodeSearch : NodeSearchSpec = {
    <tok_def:(TOK "=")?> <val:TextSearch>=> {
        let spec = match val.1 { 
            ast::StringMatchType::Exact => {
                NodeSearchSpec::ExactTokenValue {
                    val: val.0,
                    leafs_only: tok_def.is_some(),
                }
            },
            ast::StringMatchType::Regex => {
                NodeSearchSpec::RegexTokenValue {
                    val: val.0,
                    leafs_only: tok_def.is_some(),
                }
            },
        };
        spec
    },
    <name:QName> "=" <text:TextSearch> => {
        let spec = match text.1 { 
            ast::StringMatchType::Exact => {
                NodeSearchSpec::ExactValue {
                    ns: name.0,
                    name: name.1,
                    val: Some(text.0),
                    is_meta: false,
                }
            },
            ast::StringMatchType::Regex => {
                NodeSearchSpec::RegexValue {
                    ns: name.0,
                    name: name.1,
                    val: text.0,
                    is_meta: false,
                }
            },
        };
        spec
    },
    <name:QName>=> {
        let spec = NodeSearchSpec::ExactValue {
            ns: name.0,
            name: name.1,
            val: None,
            is_meta: false,
        };
        spec
    },
}


NodeRef : ast::NodeRef = {
    <v:NODE_REF> => ast::NodeRef::ID(v[1..].parse::<u32>().unwrap()),
    <v:NAMED_NODE_REF> => ast::NodeRef::Name(v[1..].to_string()),
}

BinaryOpSpec : ast::BinaryOpSpec = {
    <type_def:r">([a-zA-Z][a-zA-Z0-9]*)?"> => {
        let name = type_def[">".len()..].to_string();
        ast::BinaryOpSpec::Dominance(DominanceSpec {
            name,
            min_dist: 1,
            max_dist: 1,
            edge_anno: None,
        })
    },
    <type_def:r"->[a-zA-Z][a-zA-Z0-9]*"> => {
        let name = type_def["->".len()..].to_string();
        ast::BinaryOpSpec::Pointing(PointingSpec {
            name,
            min_dist: 1,
            max_dist: 1,
            edge_anno: None,
        })
    },
    "." => ast::BinaryOpSpec::Precedence(PrecedenceSpec {
        segmentation: None,
        min_dist: 1,
        max_dist: 1,
    }),
    "_o_" => ast::BinaryOpSpec::Overlap(OverlapSpec {}),
    "_=_" => ast::BinaryOpSpec::IdenticalCoverage(IdenticalCoverageSpec {}),
}

TextSearch: ast::TextSearch = {
    <v:r#""[^"]*""#> => ast::TextSearch(String::from(&v[1..v.len()-1]), ast::StringMatchType::Exact),
    // see https://stackoverflow.com/questions/37032620/regex-for-matching-a-string-literal-in-java 
    // for a example how to match escaped quotation characters
    <v:r#"/[^"\\]*(\\.[^"\\]*)*/"#> => ast::TextSearch(String::from(&v[1..v.len()-1]), ast::StringMatchType::Regex),
};

QName: ast::QName = {
    <ns:ID> ":" <name:ID> => ast::QName(Some(String::from(ns)), String::from(name)),
    <name:ID> => ast::QName(None, String::from(name)),
    
};


